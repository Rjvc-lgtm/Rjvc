<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8" />
  <title>RJVC Binary Tree Admin (Level Commission)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    *{box-sizing:border-box;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;}
    body{margin:0;background:#f3f4f6;color:#111827;}
    h1,h2,h3{margin:0 0 8px;}
    .page{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:16px;}
    .card{background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,.15);padding:22px;max-width:1000px;width:100%;}
    label{display:block;font-size:14px;margin-bottom:4px;}
    input{width:100%;padding:10px 12px;border-radius:999px;border:1px solid #d1d5db;font-size:15px;outline:none;}
    input:focus{border-color:#2563eb;box-shadow:0 0 0 2px rgba(37,99,235,.25);}
    .btn{border:none;border-radius:999px;padding:10px 18px;font-size:15px;font-weight:600;cursor:pointer;}
    .btn-primary{background:#2563eb;color:#fff;}
    .btn-secondary{background:#e5e7eb;color:#111827;}
    .btn-danger{background:#dc2626;color:#fff;}
    .btn-sm{padding:6px 10px;font-size:12px;}
    .mt-1{margin-top:4px;}
    .mt-2{margin-top:8px;}
    .mt-3{margin-top:12px;}
    .mt-4{margin-top:16px;}
    .flex{display:flex;}
    .between{justify-content:space-between;align-items:center;}
    table{width:100%;border-collapse:collapse;font-size:13px;margin-top:8px;}
    th,td{padding:6px 4px;border-bottom:1px solid #e5e7eb;text-align:left;}
    th{font-size:12px;text-transform:uppercase;color:#6b7280;}
    .panel{background:#fff;border-radius:18px;box-shadow:0 8px 24px rgba(15,23,42,.1);padding:18px;margin-bottom:18px;}
    .tree-panel{background:#020617;color:#e5e7eb;border-radius:18px;padding:16px;margin-top:8px;}
    .tree-node{padding:6px 10px;border-radius:12px;background:#111827;border:1px solid #4b5563;font-size:12px;min-width:160px;}
    .tree-node-main{background:#1d4ed8;border-color:#93c5fd;}
    .small{font-size:12px;color:#6b7280;}
    .ok{color:#166534;font-size:13px;margin-top:6px;}
    .error{color:#dc2626;font-size:13px;margin-top:6px;}
    @media(max-width:720px){ .card{padding:14px;} table{font-size:12px;} }
    .tag{display:inline-block;font-size:11px;padding:2px 8px;border-radius:999px;background:#e5e7eb;color:#374151;margin-left:4px;}
  </style>
</head>
<body>

<!-- LOGIN PAGE -->
<div id="loginPage" class="page">
  <div class="card" style="max-width:480px;">
    <h1 style="text-align:center;">RJVC Admin Login</h1>
    <p style="text-align:center;font-size:13px;color:#6b7280;margin-bottom:16px;">
      यह पेज सिर्फ admin के लिए है।
    </p>
    <label>Admin ID</label>
    <input id="adminId" placeholder="जैसे: admin" />
    <div class="mt-2"></div>
    <label>Password</label>
    <input id="adminPass" type="password" placeholder="जैसे: 1234" />
    <button class="btn btn-primary mt-3" style="width:100%;" onclick="handleAdminLogin()">
      Login
    </button>
    <div id="loginError" class="error" style="display:none;">गलत ID या Password</div>
    <p style="margin-top:12px;font-size:12px;color:#6b7280;">
      Default: <b>ID: admin</b>, <b>Password: 1234</b>
    </p>
  </div>
</div>

<!-- ADMIN MAIN PAGE -->
<div id="adminPage" style="display:none;">
  <div class="card">
    <!-- HEADER -->
    <div class="panel flex between">
      <div>
        <h2>Binary Tree Admin (Level-wise Commission)</h2>
        <div class="small">
          हर ID से <b>20₹ joining income</b> मानी गई है।<br/>
          Level-wise per pair commission:
          <span class="tag">L1–4: ₹10</span>
          <span class="tag">L5: ₹8</span>
          <span class="tag">L6: ₹7</span>
          <span class="tag">L7: ₹6</span>
          <span class="tag">L8: ₹5</span>
          <span class="tag">L9: ₹4</span>
          <span class="tag">L10+: ₹3</span>
          <br/>
          हर sub ID की पूरी commission उसकी main ID के <b>Bonus Wallet</b> में जाती है।
        </div>
      </div>
      <button class="btn btn-secondary btn-sm" onclick="logout()">Logout</button>
    </div>

    <!-- CREATE ROOT CUSTOMER -->
    <div class="panel">
      <h3>नया Customer बनाएं (Root level)</h3>
      <div class="flex" style="gap:10px;flex-wrap:wrap;margin-top:8px;">
        <div style="flex:1 1 200px;">
          <label>Customer Name</label>
          <input id="rootName" placeholder="जैसे: Rajesh" />
        </div>
        <div style="flex:1 1 200px;">
          <label>Customer Password (Login के लिए)</label>
          <input id="rootPass" placeholder="जैसे: 1234" />
        </div>
      </div>
      <button class="btn btn-primary mt-3" onclick="createRootCustomer()">
        Root में नया Customer जोड़ें
      </button>
      <div id="rootMsg" class="ok" style="display:none;"></div>
      <p class="small" style="margin-top:6px;">
        एक main ID बनाओ, उसके नीचे +Member से उसकी sub IDs जोड़ो। System auto calculation करेगा।
      </p>
    </div>

    <!-- COMPANY BUSINESS REPORT -->
    <div class="panel">
      <h3>Company Business Report (Auto)</h3>
      <div class="small">
        IDs × 20₹ = Business Income, minus total binary payout (commission wallets) = Approx Company Profit.
      </div>
      <div style="margin-top:10px;display:flex;flex-wrap:wrap;gap:10px;">
        <div class="small">Total Customers: <b id="totalCustomers">0</b></div>
        <div class="small">Total Pairs: <b id="totalPairs">0</b></div>
        <div class="small">Total Binary Income (कट के बाद): <b id="totalCommission">₹0</b></div>
        <div class="small">Company Approx Profit: <b id="companyProfit">₹0</b></div>
      </div>
    </div>

    <!-- CUSTOMER LIST -->
    <div class="panel">
      <div class="flex between">
        <h3>Customer List (Tree Nodes)</h3>
        <span class="small" id="totalCustomersBadge">0 Customers</span>
      </div>
      <div style="overflow-x:auto;margin-top:10px;">
        <table>
          <thead>
          <tr>
            <th>#</th>
            <th>Name</th>
            <th>Password</th>
            <th>Level</th>
            <th>Members (नीचे)</th>
            <th>Pairs</th>
            <th>Binary Income (₹)</th>
            <th>Tree</th>
            <th>Del</th>
          </tr>
          </thead>
          <tbody id="customerTableBody"></tbody>
        </table>
      </div>
      <p class="small" style="margin-top:6px;">
        Logic: हर 2 member = 1 pair. Commission ऊपर वाले level-rule से auto calculate हो रही है।
        यह earning members को जाती है। Sub IDs की commission पूरी उनकी main ID के bonus में जाती है।
      </p>
    </div>

    <!-- TREE VIEW -->
    <div class="tree-panel">
      <div class="flex between">
        <div>
          <div class="small" id="treeRootInfo">अभी कोई root select नहीं है।</div>
        </div>
        <button class="btn btn-secondary btn-sm" onclick="showFullRootTree()">सिर्फ Root दिखाओ</button>
      </div>
      <div id="treeViewArea" style="margin-top:12px;"></div>
    </div>
  </div>
</div>

<!-- FIREBASE -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>

<script>
/********** CONFIG **********/
const firebaseConfig = {
  apiKey: "AIzaSyBDw_FQyDzWZLJORFtOwZqrFRfeS5tOFSw",
  authDomain: "rjvc-plan.firebaseapp.com",
  projectId: "rjvc-plan",
  storageBucket: "rjvc-plan.firebasestorage.app",
  messagingSenderId: "265431528728",
  appId: "1:265431528728:web:c3dc4b8e8f3ae4469a1a6d",
  measurementId: "G-1Y7PN96H93"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
const treeCol = db.collection("TreeNodes");
const usersCol = db.collection("Users");

/********** ADMIN AUTH **********/
const ADMIN_ID = "admin";
const ADMIN_PASSWORD = "1234";

function handleAdminLogin(){
  const id = document.getElementById("adminId").value.trim();
  const pass = document.getElementById("adminPass").value.trim();
  const err = document.getElementById("loginError");
  if(id===ADMIN_ID && pass===ADMIN_PASSWORD){
    err.style.display="none";
    document.getElementById("loginPage").style.display="none";
    document.getElementById("adminPage").style.display="block";
    startSubscriptions();
  }else{
    err.style.display="block";
  }
}
function logout(){
  document.getElementById("adminPage").style.display="none";
  document.getElementById("loginPage").style.display="flex";
  document.getElementById("adminPass").value = "";
  if(treeUnsub) treeUnsub();
}

/********** IN-MEMORY **********/
let nodesById = {};
let rootId = null;
let treeUnsub = null;
let currentTreeRootId = null;

function startSubscriptions(){
  if(treeUnsub) treeUnsub();
  treeUnsub = treeCol.orderBy("createdAt","asc").onSnapshot(snap=>{
    nodesById = {};
    rootId = null;
    snap.forEach(doc=>{
      nodesById[doc.id] = Object.assign({id:doc.id}, doc.data());
    });
    // root = parentId null
    Object.values(nodesById).forEach(n=>{
      if(!n.parentId) rootId = n.id;
    });
    recalcAll();
    renderTable();
    renderTree();
  });
}

/********** UTILITIES **********/
function countDescendants(nodeId){
  const node = nodesById[nodeId];
  if(!node) return 0;
  let c = 0;
  if(node.leftId) c += 1 + countDescendants(node.leftId);
  if(node.rightId) c += 1 + countDescendants(node.rightId);
  return c;
}

// Level = distance from root upwards (1-based)
function getLevelForNode(node){
  if(!node) return 1;
  let level = 1;
  let cur = node;
  while(cur.parentId && nodesById[cur.parentId]){
    level++;
    cur = nodesById[cur.parentId];
  }
  return level;
}

// per pair amount according to level
function getPerPairForLevel(level){
  if(level<=4) return 10;
  if(level===5) return 8;
  if(level===6) return 7;
  if(level===7) return 6;
  if(level===8) return 5;
  if(level===9) return 4;
  return 3; // level 10+
}

function collectDescendantsBFS(startId){
  const out = [];
  const q = [];
  const root = nodesById[startId];
  if(!root) return out;
  if(root.leftId) q.push(root.leftId);
  if(root.rightId) q.push(root.rightId);
  while(q.length){
    const id = q.shift();
    out.push(id);
    const n = nodesById[id];
    if(n && n.leftId) q.push(n.leftId);
    if(n && n.rightId) q.push(n.rightId);
  }
  return out;
}

/********** ROOT CUSTOMER **********/
async function createRootCustomer(){
  const name = document.getElementById("rootName").value.trim();
  const pass = document.getElementById("rootPass").value.trim();
  const msg = document.getElementById("rootMsg");
  msg.style.display="none";
  if(!name || !pass){
    msg.textContent="Name और Password दोनों चाहिए।";
    msg.className="error"; msg.style.display="block"; return;
  }
  try{
    const newRef = await treeCol.add({
      name, password:pass,
      parentId:null, leftId:null, rightId:null,
      mainAccountId:null,
      createdAt:firebase.firestore.FieldValue.serverTimestamp()
    });
    await newRef.update({ mainAccountId:newRef.id });
    await usersCol.doc(newRef.id).set({
      name, password:pass,
      commissionWallet:0, bonusWallet:0,
      mainAccountId:newRef.id
    },{merge:true});
    document.getElementById("rootName").value="";
    document.getElementById("rootPass").value="";
    msg.textContent="Root customer add हो गया।";
    msg.className="ok"; msg.style.display="block";
  }catch(err){
    msg.textContent="Error: "+err.message;
    msg.className="error"; msg.style.display="block";
  }
}

/********** REBUILD SUBTREE UNDER NEW CHILD (balanced) **********/
async function rebuildSubtreeUnder(rootId, nodesList){
  // clear parent/children for nodes to avoid loops
  const batchClear = db.batch();
  nodesList.forEach(id=>{
    const ref = treeCol.doc(id);
    batchClear.set(ref,{parentId:null,leftId:null,rightId:null},{merge:true});
  });
  await batchClear.commit();

  const rootRef = treeCol.doc(rootId);
  await rootRef.set({leftId:null,rightId:null},{merge:true});

  let i = 0;
  const q = [];

  if(nodesList.length>0){
    const left = nodesList[i++];
    await treeCol.doc(left).update({parentId:rootId});
    await rootRef.set({leftId:left},{merge:true});
    q.push(left);
  }
  if(nodesList.length>1){
    const right = nodesList[i++];
    await treeCol.doc(right).update({parentId:rootId});
    await rootRef.set({rightId:right},{merge:true});
    q.push(right);
  }

  while(i<nodesList.length){
    const parent = q.shift();
    if(!parent) break;
    const parentRef = treeCol.doc(parent);

    const left = nodesList[i++];
    await treeCol.doc(left).update({parentId:parent});
    await parentRef.set({leftId:left},{merge:true});
    q.push(left);

    if(i<nodesList.length){
      const right = nodesList[i++];
      await treeCol.doc(right).update({parentId:parent});
      await parentRef.set({rightId:right},{merge:true});
      q.push(right);
    }
  }
}

/********** ADD MEMBER (smart) **********/
async function treeAddMember(parentId){
  const sideAns = prompt("किस side जोड़ना है? Left = L/1, Right = R/2 (खाली छोड़ो = auto)");
  let side = null;
  if(sideAns){
    const s = sideAns.trim().toLowerCase();
    if(s==="l"||s==="1") side="left";
    else if(s==="r"||s==="2") side="right";
  }
  const name = prompt("नया member का नाम?");
  if(!name) return;
  const pass = prompt("उसका login password?");
  if(!pass) return;
  await addMemberSmart(parentId, side, name, pass);
}

// described earlier: if seat empty -> put there, otherwise insert + rebuild subtree under new node
async function addMemberSmart(parentId, side, name, pass){
  try{
    const parentRef = treeCol.doc(parentId);
    const parentSnap = await parentRef.get();
    if(!parentSnap.exists){ alert("Parent नहीं मिला"); return; }
    const parent = parentSnap.data();

    if(!parent.leftId || !parent.rightId){
      let placeSide = side;
      if(!placeSide) placeSide = parent.leftId ? "right" : "left";

      const newRef = await treeCol.add({
        name, password:pass,
        parentId:parentId, leftId:null, rightId:null,
        mainAccountId:parent.mainAccountId || parentId,
        createdAt:firebase.firestore.FieldValue.serverTimestamp()
      });
      await usersCol.doc(newRef.id).set({
        name, password:pass,
        commissionWallet:0, bonusWallet:0,
        mainAccountId:parent.mainAccountId || parentId
      },{merge:true});
      const upd = {}; upd[placeSide+"Id"] = newRef.id;
      await parentRef.update(upd);
      return;
    }

    // दोनों seat भरी हैं -> बीच में insert + subtree rebuild
    const newRef = await treeCol.add({
      name, password:pass,
      parentId:parentId, leftId:null, rightId:null,
      mainAccountId:parent.mainAccountId || parentId,
      createdAt:firebase.firestore.FieldValue.serverTimestamp()
    });
    await usersCol.doc(newRef.id).set({
      name, password:pass,
      commissionWallet:0, bonusWallet:0,
      mainAccountId:parent.mainAccountId || parentId
    },{merge:true});

    const allDesc = collectDescendantsBFS(parentId); // पुराने सारे descendants
    const attachSide = side==="right" ? "right" : "left";

    await parentRef.update({leftId:null,rightId:null});
    const setObj = {}; setObj[attachSide+"Id"] = newRef.id;
    await parentRef.update(setObj);

    await rebuildSubtreeUnder(newRef.id, allDesc);

  }catch(err){
    alert("Error addMemberSmart: "+err.message);
  }
}

/********** EDIT / DELETE **********/
async function editCustomer(id){
  const n = nodesById[id];
  if(!n) return;
  const newName = prompt("नया नाम?", n.name);
  if(!newName) return;
  const newPass = prompt("नया password? (खाली छोड़ो तो पुराना रहेगा)", "");
  const update = {name:newName};
  if(newPass && newPass.trim()) update.password = newPass.trim();
  try{
    await treeCol.doc(id).update(update);
    await usersCol.doc(id).set(update,{merge:true});
  }catch(err){
    alert("Error: "+err.message);
  }
}

async function deleteCustomer(id){
  const node = nodesById[id];
  if(!node) return;
  if(!confirm(`"${node.name}" और उसका पूरा subtree delete होगा, आगे बढ़ें?`)) return;

  try{
    if(node.parentId){
      const parentRef = treeCol.doc(node.parentId);
      const parent = nodesById[node.parentId];
      if(parent){
        const upd = {};
        if(parent.leftId===id) upd.leftId=null;
        if(parent.rightId===id) upd.rightId=null;
        await parentRef.update(upd);
      }
    }
    async function deleteSubTree(nid){
      const n = nodesById[nid];
      if(!n) return;
      if(n.leftId) await deleteSubTree(n.leftId);
      if(n.rightId) await deleteSubTree(n.rightId);
      await treeCol.doc(nid).delete();
      await usersCol.doc(nid).delete();
    }
    await deleteSubTree(id);
  }catch(err){
    alert("Delete Error: "+err.message);
  }
}

/********** RECALC / WALLETS / RENDER **********/
let globalTotalPairs = 0;
let globalTotalCommission = 0;
let globalTotalCustomers = 0;

async function recalcAll(){
  globalTotalPairs=0;
  globalTotalCommission=0;
  globalTotalCustomers = Object.keys(nodesById).length;

  const list = Object.values(nodesById);

  list.forEach(n=>{
    const level = getLevelForNode(n);
    const members = countDescendants(n.id);
    const pairs = Math.floor(members/2);
    const perPair = getPerPairForLevel(level);
    const comm = pairs * perPair;

    n.level = level;
    n.members = members;
    n.pairs = pairs;
    n.commission = comm;

    globalTotalPairs += pairs;
    globalTotalCommission += comm;
  });

  const bizInc = globalTotalCustomers * 20;
  const companyProfit = Math.round((bizInc - globalTotalCommission)*100)/100;

  document.getElementById("totalCustomers").textContent = globalTotalCustomers;
  document.getElementById("totalPairs").textContent = globalTotalPairs;
  document.getElementById("totalCommission").textContent = "₹"+globalTotalCommission;
  document.getElementById("companyProfit").textContent = "₹"+companyProfit;

  await updateUsersWallets();
}

// sub की पूरी commission main के bonus में जाती है
async function updateUsersWallets(){
  const list = Object.values(nodesById);
  const bonusMap = {}; // mainId -> amount

  // ensure mainAccountId
  list.forEach(n=>{
    if(!n.mainAccountId){
      let cur = n;
      while(cur.parentId && nodesById[cur.parentId]){
        cur = nodesById[cur.parentId];
      }
      n.mainAccountId = cur.id;
    }
  });

  list.forEach(n=>{
    const mainId = n.mainAccountId || n.id;
    if(mainId !== n.id){
      const subComm = n.commission || 0;
      bonusMap[mainId] = (bonusMap[mainId] || 0) + subComm;
    }
  });

  const batch = db.batch();
  list.forEach(n=>{
    const uRef = usersCol.doc(n.id);
    const data = {
      name:n.name || "",
      password:n.password || "",
      commissionWallet:n.commission || 0,
      bonusWallet:+((bonusMap[n.id] || 0).toFixed(2)),
      mainAccountId:n.mainAccountId || n.id
    };
    batch.set(uRef,data,{merge:true});
  });
  await batch.commit();
}

function renderTable(){
  const tbody = document.getElementById("customerTableBody");
  tbody.innerHTML="";
  const list = Object.values(nodesById).sort((a,b)=>(a.name||"").localeCompare(b.name||""));
  document.getElementById("totalCustomersBadge").textContent = list.length+" Customers";
  list.forEach((n,idx)=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${idx+1}</td>
      <td>${n.name||""}</td>
      <td>${n.password||""}</td>
      <td>L${n.level||1}</td>
      <td>${n.members||0}</td>
      <td>${n.pairs||0}</td>
      <td>₹${n.commission||0}</td>
      <td><button class="btn btn-secondary btn-sm" onclick="viewTreeFrom('${n.id}')">Tree</button></td>
      <td><button class="btn btn-danger btn-sm" onclick="deleteCustomer('${n.id}')">Del</button></td>
    `;
    tbody.appendChild(tr);
  });
}

function viewTreeFrom(id){
  currentTreeRootId = id;
  renderTree();
}
function showFullRootTree(){
  currentTreeRootId = rootId;
  renderTree();
}

function renderTree(){
  const area = document.getElementById("treeViewArea");
  const info = document.getElementById("treeRootInfo");
  if(!Object.keys(nodesById).length){
    info.textContent="Tree खाली है।";
    area.textContent="";
    return;
  }
  const startId = currentTreeRootId || rootId;
  const startNode = nodesById[startId];
  if(!startNode){
    info.textContent="Tree root नहीं मिला।";
    area.textContent="";
    return;
  }
  info.innerHTML = `अभी tree <b>${startNode.name}</b> से शुरू हो रहा है (Level: ${startNode.level||1}, Members: ${startNode.members||0}, Pairs: ${startNode.pairs||0}, Binary Income: ₹${startNode.commission||0})`;

  let q = [startId];
  let html = "";
  while(q.length){
    const levelIds = [...q];
    html += `<div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:10px;">`;
    levelIds.forEach(id=>{
      const n = nodesById[id];
      if(!n) return;
      html += `
        <div class="tree-node ${id===startId?'tree-node-main':''}">
          <div style="font-weight:600;">${n.name}</div>
          <div style="font-size:11px;color:#9ca3af;margin-top:4px;">
            L${n.level||1} · M:${n.members||0} · P:${n.pairs||0} · ₹${n.commission||0}
          </div>
          <div style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap;">
            <button class="btn btn-secondary btn-sm" onclick="treeAddMember('${n.id}')">+Member</button>
            <button class="btn btn-secondary btn-sm" onclick="editCustomer('${n.id}')">Edit</button>
            <button class="btn btn-danger btn-sm" onclick="deleteCustomer('${n.id}')">Del</button>
          </div>
        </div>
      `;
    });
    html += `</div>`;
    const next = [];
    levelIds.forEach(id=>{
      const n = nodesById[id];
      if(!n) return;
      if(n.leftId) next.push(n.leftId);
      if(n.rightId) next.push(n.rightId);
    });
    q = next;
  }
  area.innerHTML = html;
}
</script>
</body>
</html>
