<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8" />
  <title>RJVC Binary Tree Admin (Updated)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* (same styling as before, condensed) */
    *{box-sizing:border-box;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;}
    body{margin:0;background:#f3f4f6;color:#111827;}
    h1,h2,h3{margin:0 0 8px;}
    .page{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:16px;}
    .card{background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,.15);padding:22px;max-width:1000px;width:100%;}
    label{display:block;font-size:14px;margin-bottom:4px;}
    input{width:100%;padding:10px 12px;border-radius:999px;border:1px solid #d1d5db;font-size:15px;outline:none;}
    .btn{border:none;border-radius:999px;padding:10px 18px;font-size:15px;font-weight:600;cursor:pointer;}
    .btn-primary{background:#2563eb;color:#fff;}
    .btn-secondary{background:#e5e7eb;color:#111827;}
    .btn-danger{background:#dc2626;color:#fff;}
    .btn-sm{padding:6px 10px;font-size:12px;}
    .mt-1{margin-top:4px;}
    .mt-2{margin-top:8px;}
    .mt-3{margin-top:12px;}
    .mt-4{margin-top:16px;}
    .flex{display:flex;}
    .between{justify-content:space-between;align-items:center;}
    table{width:100%;border-collapse:collapse;font-size:13px;margin-top:8px;}
    th,td{padding:6px 4px;border-bottom:1px solid #e5e7eb;text-align:left;}
    th{font-size:12px;text-transform:uppercase;color:#6b7280;}
    .panel{background:#fff;border-radius:18px;box-shadow:0 8px 24px rgba(15,23,42,.1);padding:18px;margin-bottom:18px;}
    .tree-panel{background:#020617;color:#e5e7eb;border-radius:18px;padding:16px;margin-top:8px;}
    .tree-node{padding:6px 10px;border-radius:12px;background:#111827;border:1px solid #4b5563;font-size:12px;min-width:140px;}
    .tree-node-main{background:#1d4ed8;border-color:#93c5fd;}
    .small{font-size:12px;color:#6b7280;}
    .ok{color:#166534;font-size:13px;margin-top:6px;}
    .error{color:#dc2626;font-size:13px;margin-top:6px;}
    @media(max-width:720px){ .card{padding:14px;} table{font-size:12px;} }
  </style>
</head>
<body>

<!-- LOGIN PAGE -->
<div id="loginPage" class="page">
  <div class="card" style="max-width:480px;">
    <h1 class="center">RJVC Admin Login</h1>
    <p class="center" style="font-size:13px;color:#6b7280;margin-bottom:16px;">यह पेज सिर्फ admin के लिए है।</p>
    <label>Admin ID</label>
    <input id="adminId" placeholder="जैसे: admin" />
    <div class="mt-2"></div>
    <label>Password</label>
    <input id="adminPass" type="password" placeholder="जैसे: 1234" />
    <button class="btn btn-primary mt-3" style="width:100%;" onclick="handleAdminLogin()">Login</button>
    <div id="loginError" class="error" style="display:none;">गलत ID या Password</div>
    <p style="margin-top:12px;font-size:12px;color:#6b7280;">Default: <b>ID: admin</b>, <b>Password: 1234</b></p>
  </div>
</div>

<!-- ADMIN MAIN PAGE -->
<div id="adminPage" style="display:none;">
  <div class="card">
    <div class="panel flex between">
      <div>
        <h2>Binary Tree Admin (Firebase) — Updated</h2>
        <div class="small">
          हर ID से <b>20₹ joining income</b> माना गया है।<br/>
          Commission per pair और level-rules admin में set किए जा सकते हैं।<br/>
          जब नया node बीच में जुड़ता है तो subtree auto rebalance होता है (level-order).
        </div>
      </div>
      <button class="btn btn-secondary btn-sm" onclick="logout()">Logout</button>
    </div>

    <!-- CREATE ROOT CUSTOMER -->
    <div class="panel">
      <h3>नया Customer बनाएं (Root level)</h3>
      <div class="flex" style="gap:10px;flex-wrap:wrap;margin-top:8px;">
        <div style="flex:1 1 200px;">
          <label>Customer Name</label>
          <input id="rootName" placeholder="जैसे: Rajesh" />
        </div>
        <div style="flex:1 1 200px;">
          <label>Customer Password (Login के लिए)</label>
          <input id="rootPass" placeholder="जैसे: 1234" />
        </div>
      </div>
      <button class="btn btn-primary mt-3" onclick="createRootCustomer()">Root में नया Customer जोड़ें</button>
      <div id="rootMsg" class="ok" style="display:none;"></div>
      <p class="small" style="margin-top:6px;">एक main ID बनाओ, उसके नीचे +Member से उसकी sub IDs जोड़ो। System auto calculation करेगा।</p>
    </div>

    <!-- COMPANY BUSINESS REPORT -->
    <div class="panel">
      <h3>Company Business Report (Auto)</h3>
      <div class="small">पूरा tree से calculation: IDs × 20₹ = Business Income, minus payouts = Company Profit</div>
      <div style="margin-top:10px;">
        <div class="small">Total Customers: <b id="totalCustomers">0</b></div>
        <div class="small">Total Pairs: <b id="totalPairs">0</b></div>
        <div class="small">Total Binary Income: <b id="totalCommission">₹0</b></div>
        <div class="small">Company Approx Profit: <b id="companyProfit">₹0</b></div>
      </div>
    </div>

    <!-- CUSTOMER LIST -->
    <div class="panel">
      <div class="flex between">
        <h3>Customer List (Tree Nodes)</h3>
        <span class="small" id="totalCustomersBadge">0 Customers</span>
      </div>
      <div style="overflow-x:auto;margin-top:10px;">
        <table>
          <thead>
            <tr><th>#</th><th>Name</th><th>Password</th><th>Members (नीचे)</th><th>Pairs</th><th>Binary Income (₹)</th><th>Tree</th><th>Del</th></tr>
          </thead>
          <tbody id="customerTableBody"></tbody>
        </table>
      </div>
      <p class="small" style="margin-top:6px;">Logic: हर 2 member = 1 pair. Commission, bonus auto compute होते हैं.</p>
    </div>

    <!-- TREE VIEW -->
    <div class="tree-panel">
      <div class="flex between">
        <div>
          <div class="small" id="treeRootInfo">अभी कोई root select नहीं है।</div>
        </div>
        <button class="btn btn-secondary btn-sm" onclick="showFullRootTree()">सिर्फ Root दिखाओ</button>
      </div>
      <div id="treeViewArea" style="margin-top:12px;"></div>
    </div>
  </div>
</div>

<!-- FIREBASE -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>

<script>
  /********** CONFIG **********/
  const firebaseConfig = {
    apiKey: "AIzaSyBDw_FQyDzWZLJORFtOwZqrFRfeS5tOFSw",
    authDomain: "rjvc-plan.firebaseapp.com",
    projectId: "rjvc-plan",
    storageBucket: "rjvc-plan.firebasestorage.app",
    messagingSenderId: "265431528728",
    appId: "1:265431528728:web:c3dc4b8e8f3ae4469a1a6d",
    measurementId: "G-1Y7PN96H93"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  const treeCol = db.collection("TreeNodes");
  const usersCol = db.collection("Users");

  /********** ADMIN AUTH (SIMPLE) **********/
  const ADMIN_ID = "admin";
  const ADMIN_PASSWORD = "1234";
  function handleAdminLogin(){
    const id = document.getElementById("adminId").value.trim();
    const pass = document.getElementById("adminPass").value.trim();
    const err = document.getElementById("loginError");
    if(id===ADMIN_ID && pass===ADMIN_PASSWORD){
      err.style.display="none";
      document.getElementById("loginPage").style.display="none";
      document.getElementById("adminPage").style.display="block";
      startSubscriptions();
    } else {
      err.style.display="block";
    }
  }
  function logout(){
    document.getElementById("adminPage").style.display="none";
    document.getElementById("loginPage").style.display="flex";
    document.getElementById("adminPass").value = "";
    if(treeUnsub) treeUnsub();
  }

  /********** IN-MEMORY **********/
  let nodesById = {};
  let rootId = null;
  let treeUnsub = null;

  function startSubscriptions(){
    if(treeUnsub) treeUnsub();
    treeUnsub = treeCol.orderBy("createdAt","asc").onSnapshot(snap=>{
      nodesById = {};
      rootId = null;
      snap.forEach(doc=>{
        nodesById[doc.id] = Object.assign({ id: doc.id }, doc.data());
      });
      // find root (parentId == null)
      Object.values(nodesById).forEach(n=>{
        if(!n.parentId) rootId = n.id;
      });
      recalcAll();
      renderTable();
      renderTree();
    });
  }

  /********** UTILITIES **********/
  function countDescendants(nodeId){
    const node = nodesById[nodeId];
    if(!node) return 0;
    let c = 0;
    if(node.leftId) c += 1 + countDescendants(node.leftId);
    if(node.rightId) c += 1 + countDescendants(node.rightId);
    return c;
  }

  function collectDescendantsBFS(startId){
    // returns array of nodeIds in BFS order (excluding startId)
    const out = [];
    const q = [];
    const root = nodesById[startId];
    if(!root) return out;
    if(root.leftId) q.push(root.leftId);
    if(root.rightId) q.push(root.rightId);
    while(q.length){
      const id = q.shift();
      out.push(id);
      const n = nodesById[id];
      if(n && n.leftId) q.push(n.leftId);
      if(n && n.rightId) q.push(n.rightId);
    }
    return out;
  }

  async function updateDocFields(id, obj){
    await treeCol.doc(id).set(obj, { merge:true });
  }

  /********** CREATE ROOT CUSTOMER **********/
  async function createRootCustomer(){
    const name = document.getElementById("rootName").value.trim();
    const pass = document.getElementById("rootPass").value.trim();
    const msg = document.getElementById("rootMsg");
    msg.style.display="none";
    if(!name || !pass){ msg.textContent="Name और Password दोनों चाहिए"; msg.className="error"; msg.style.display="block"; return; }
    try{
      const newRef = await treeCol.add({
        name, password: pass, parentId: null, leftId: null, rightId: null, mainAccountId: null,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      });
      await newRef.update({ mainAccountId: newRef.id });
      await usersCol.doc(newRef.id).set({
        name, password: pass, commissionWallet:0, bonusWallet:0, mainAccountId: newRef.id
      }, { merge:true });
      document.getElementById("rootName").value = "";
      document.getElementById("rootPass").value = "";
      msg.textContent = "Root customer add हो गया।"; msg.className="ok"; msg.style.display="block";
    }catch(err){
      msg.textContent = "Error: " + err.message; msg.className="error"; msg.style.display="block";
    }
  }

  /********** REBUILD SUBTREE - helper **********/
  // Given a root id and an ordered list of nodeIds, assign them into a balanced binary tree under root
  // nodesList: array of nodeIds (these nodes already exist; we'll reassign parentId/leftId/rightId)
  async function rebuildSubtreeUnder(rootId, nodesList){
    // clear references for the nodes we will reattach
    const batch = db.batch();
    // clear all left/right/parent for nodes in nodesList first (to avoid cycles)
    nodesList.forEach(id => {
      const ref = treeCol.doc(id);
      batch.set(ref, { parentId: null, leftId: null, rightId: null }, { merge:true });
    });
    await batch.commit();

    // Now assign in BFS: root.left = nodesList[0], root.right = nodesList[1], then continue for each assigned node
    const assignments = []; // pairs [parentId, leftId, rightId?]
    const q = [];
    let i = 0;
    if(nodesList.length > 0){
      const left = nodesList[i++]; await treeCol.doc(left).update({ parentId: rootId }); await treeCol.doc(rootId).set({ leftId: left }, { merge:true });
      q.push(left);
    }
    if(nodesList.length > 1){
      const right = nodesList[i++]; await treeCol.doc(right).update({ parentId: rootId }); await treeCol.doc(rootId).set({ rightId: right }, { merge:true });
      q.push(right);
    }
    while(i < nodesList.length){
      const parent = q.shift();
      if(!parent) break;
      const left = nodesList[i++];
      await treeCol.doc(left).update({ parentId: parent });
      await treeCol.doc(parent).set({ leftId: left }, { merge:true });
      q.push(left);
      if(i < nodesList.length){
        const right = nodesList[i++];
        await treeCol.doc(right).update({ parentId: parent });
        await treeCol.doc(parent).set({ rightId: right }, { merge:true });
        q.push(right);
      }
    }
  }

  /********** ADD MEMBER (with intelligent rebalance) **********/
  // parentId: where admin clicked +Member
  // side: "left" or "right" or null (auto)
  async function treeAddMember(parentId){
    const sideAns = prompt("किस side जोड़ना है? Left = L या 1, Right = R या 2 (खाली छोड़ो = auto)");
    let side = null;
    if(sideAns){
      const s = sideAns.trim().toLowerCase();
      if(s==='l' || s==='1') side = 'left';
      else if(s==='r' || s==='2') side = 'right';
    }
    const name = prompt("नया member का नाम?");
    if(!name) return;
    const pass = prompt("उसका login password?");
    if(!pass) return;

    await addMemberSmart(parentId, side, name, pass);
  }

  // Smart add: if parent has empty slot -> put there
  // if both slots full -> insert new node as child of parent (on chosen side or left by default),
  // then collect ALL previous descendants of parent (excluding parent) and rebuild subtree under the newly created child (balanced BFS).
  async function addMemberSmart(parentId, side, name, pass){
    try{
      const parentRef = treeCol.doc(parentId);
      const parentSnap = await parentRef.get();
      if(!parentSnap.exists){ alert("Parent नहीं मिला"); return; }
      const parent = parentSnap.data();

      // if parent has empty left or right, put there directly
      if(!parent.leftId || !parent.rightId){
        // choose side
        let placeSide = side;
        if(!placeSide){
          placeSide = parent.leftId ? 'right' : 'left';
        }
        const newRef = await treeCol.add({
          name, password: pass, parentId: parentId, leftId: null, rightId: null,
          mainAccountId: parent.mainAccountId || parentId, createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        await usersCol.doc(newRef.id).set({
          name, password: pass, commissionWallet: 0, bonusWallet: 0, mainAccountId: parent.mainAccountId || parentId
        }, { merge:true });

        const upd = {};
        upd[placeSide+'Id'] = newRef.id;
        await parentRef.update(upd);
        return;
      }

      // both occupied -> we'll insert new child and rebuild subtree under that new child
      // create new node (attach to parent temporarily but clear parent's existing children first)
      const newRef = await treeCol.add({
        name, password: pass, parentId: parentId, leftId: null, rightId: null,
        mainAccountId: parent.mainAccountId || parentId, createdAt: firebase.firestore.FieldValue.serverTimestamp()
      });
      await usersCol.doc(newRef.id).set({
        name, password: pass, commissionWallet: 0, bonusWallet: 0, mainAccountId: parent.mainAccountId || parentId
      }, { merge:true });

      // collect all descendants under parent (old subtree), in BFS order
      const allDesc = collectDescendantsBFS(parentId); // array of nodeIds (old children + deeper)
      // Now clear parent left/right to attach newRef as one child and rebuild under newRef
      // We'll attach newRef to parent's left if side == 'left', right if 'right', else left by default.
      const attachSide = side === 'right' ? 'right' : 'left';
      // set parent's attachSide = newRef.id, and temporarily clear other child (we'll include them in allDesc)
      // But to avoid dangling references we will set both leftId/rightId = null on parent first
      await parentRef.update({ leftId: null, rightId: null });
      // attach newRef to parent on attachSide
      const setObj = {};
      setObj[attachSide+'Id'] = newRef.id;
      await parentRef.update(setObj);

      // rebuild subtree under newRef using allDesc (balanced)
      await rebuildSubtreeUnder(newRef.id, allDesc);

    }catch(err){
      alert("Error addMemberSmart: " + err.message);
    }
  }

  /********** Edit / Delete **********/
  async function editCustomer(id){
    const n = nodesById[id];
    if(!n) return;
    const newName = prompt("नया नाम?", n.name);
    if(!newName) return;
    const newPass = prompt("नया password? (खाली छोड़ो तो पुराना रहेगा)", "");
    const update = { name: newName };
    if(newPass && newPass.trim()) update.password = newPass.trim();
    try{
      await treeCol.doc(id).update(update);
      await usersCol.doc(id).set(update, { merge:true });
    }catch(err){
      alert("Error: " + err.message);
    }
  }

  async function deleteCustomer(id){
    const node = nodesById[id];
    if(!node) return;
    if(!confirm(`"${node.name}" और उसका पूरा subtree delete होगा, आगे बढ़ें?`)) return;

    try{
      if(node.parentId){
        const parentRef = treeCol.doc(node.parentId);
        const parent = nodesById[node.parentId];
        if(parent){
          const upd = {};
          if(parent.leftId === id) upd.leftId = null;
          if(parent.rightId === id) upd.rightId = null;
          await parentRef.update(upd);
        }
      }

      // recursively delete subtree nodes and corresponding users documents
      async function deleteSubTree(nid){
        const n = nodesById[nid];
        if(!n) return;
        if(n.leftId) await deleteSubTree(n.leftId);
        if(n.rightId) await deleteSubTree(n.rightId);
        await treeCol.doc(nid).delete();
        await usersCol.doc(nid).delete();
      }
      await deleteSubTree(id);
    }catch(err){
      alert("Delete Error: " + err.message);
    }
  }

  /********** Recalc/Wallets/Render **********/
  let globalTotalPairs = 0;
  let globalTotalCommission = 0;
  let globalTotalCustomers = 0;

  async function recalcAll(){
    globalTotalPairs = 0;
    globalTotalCommission = 0;
    globalTotalCustomers = Object.keys(nodesById).length;

    const list = Object.values(nodesById);
    // compute members, pairs, commission (per pair amount and level rules can be adjusted)
    // For demo we keep per pair amount fixed at 10 for now (you can change scale easily)
    const perPairAmount = 10; // as per your later requests you can change to level-based
    list.forEach(n=>{
      const members = countDescendants(n.id);
      const pairs = Math.floor(members/2);
      const comm = pairs * perPairAmount;
      n.members = members;
      n.pairs = pairs;
      n.commission = comm;
      globalTotalPairs += pairs;
      globalTotalCommission += comm;
    });

    const bizInc = globalTotalCustomers * 20;
    const companyProfit = Math.round((bizInc - globalTotalCommission) * 100)/100;

    document.getElementById("totalCustomers").textContent = globalTotalCustomers;
    document.getElementById("totalPairs").textContent = globalTotalPairs;
    document.getElementById("totalCommission").textContent = "₹" + globalTotalCommission;
    document.getElementById("companyProfit").textContent = "₹" + companyProfit;

    // update Users collection wallets
    await updateUsersWallets();
  }

  // IMPORTANT: This function updates Users collection so that:
  // - Each user's commissionWallet = that node's commission
  // - For every node that belongs to some mainAccount (mainAccountId != node.id),
  //   the entire sub-node commission is added to that mainAccount's bonusWallet.
  // (based on user's last request to have full sub-commission appear in main bonus)
  async function updateUsersWallets(){
    const list = Object.values(nodesById);
    const bonusMap = {}; // mainId -> total bonus to add

    // ensure every node has mainAccountId field set
    list.forEach(n=>{
      // fallback: find top-level ancestor if not present
      if(!n.mainAccountId){
        let cur = n;
        while(cur.parentId && nodesById[cur.parentId]){
          cur = nodesById[cur.parentId];
        }
        n.mainAccountId = cur.id;
      }
    });

    // accumulate bonuses from sub nodes into main accounts (full commission)
    list.forEach(n=>{
      const mainId = n.mainAccountId || n.id;
      if(mainId !== n.id){
        const subComm = n.commission || 0;
        bonusMap[mainId] = (bonusMap[mainId] || 0) + subComm;
      }
    });

    // write batch: commissionWallet = node.commission, bonusWallet = bonusMap[node.id] (or existing merged)
    const batch = db.batch();
    list.forEach(n=>{
      const uRef = usersCol.doc(n.id);
      const data = {
        name: n.name || "",
        password: n.password || "",
        commissionWallet: n.commission || 0,
        bonusWallet: +( (bonusMap[n.id] || 0).toFixed(2) ),
        mainAccountId: n.mainAccountId || n.id
      };
      batch.set(uRef, data, { merge:true });
    });
    await batch.commit();
  }

  function renderTable(){
    const tbody = document.getElementById("customerTableBody");
    tbody.innerHTML = "";
    const list = Object.values(nodesById).sort((a,b)=> (a.name||"").localeCompare(b.name||""));
    document.getElementById("totalCustomersBadge").textContent = list.length + " Customers";
    list.forEach((n, idx)=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${idx+1}</td>
        <td>${n.name||""}</td>
        <td>${n.password||""}</td>
        <td>${n.members||0}</td>
        <td>${n.pairs||0}</td>
        <td>₹${n.commission||0}</td>
        <td><button class="btn btn-secondary btn-sm" onclick="viewTreeFrom('${n.id}')">Tree</button></td>
        <td><button class="btn btn-danger btn-sm" onclick="deleteCustomer('${n.id}')">Del</button></td>`;
      tbody.appendChild(tr);
    });
  }

  function viewTreeFrom(id){
    currentTreeRootId = id;
    renderTree();
  }
  function showFullRootTree(){
    currentTreeRootId = rootId;
    renderTree();
  }

  let currentTreeRootId = null;
  function renderTree(){
    const area = document.getElementById("treeViewArea");
    const info = document.getElementById("treeRootInfo");
    if(!Object.keys(nodesById).length){
      info.textContent = "Tree खाली है।";
      area.textContent = "";
      return;
    }
    const startId = currentTreeRootId || rootId;
    const startNode = nodesById[startId];
    if(!startNode){
      info.textContent = "Tree root नहीं मिला।";
      area.textContent = "";
      return;
    }
    info.innerHTML = `अभी tree <b>${startNode.name}</b> से शुरू हो रहा है (Members: ${startNode.members||0}, Pairs: ${startNode.pairs||0}, Binary Income: ₹${startNode.commission||0})`;

    // build simple level view using BFS (starting from startId)
    const build = (ids) => {
      let html = "";
      html += `<div style="display:flex;flex-direction:column;gap:12px;">`;
      // for each id show a node box
      ids.forEach(id=>{
        const n = nodesById[id];
        if(!n) return;
        html += `<div style="display:flex;gap:12px;align-items:center;">
          <div class="tree-node ${id===rootId ? 'tree-node-main':''}">
            <div style="font-weight:600;">${n.name}</div>
            <div style="font-size:12px;color:#9ca3af;margin-top:4px;">M:${n.members||0} · P:${n.pairs||0} · ₹${n.commission||0}</div>
            <div style="margin-top:8px;display:flex;gap:6px;">
              <button class="btn btn-secondary btn-sm" onclick="treeAddMember('${n.id}')">+Member</button>
              <button class="btn btn-secondary btn-sm" onclick="editCustomer('${n.id}')">Edit</button>
              <button class="btn btn-danger btn-sm" onclick="deleteCustomer('${n.id}')">Del</button>
            </div>
          </div>
        </div>`;
      });
      html += `</div>`;
      return html;
    };

    // create levels
    let q = [startId];
    let levelsHtml = "";
    while(q.length){
      const level = [...q];
      levelsHtml += `<div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:10px;">`;
      level.forEach(id=>{
        const n = nodesById[id];
        if(!n) return;
        levelsHtml += `<div class="tree-node ${id===startId ? 'tree-node-main':''}" style="min-width:160px;">
          <div style="font-weight:600;">${n.name}</div>
          <div style="font-size:12px;color:#9ca3af;margin-top:4px;">M:${n.members||0} · P:${n.pairs||0} · ₹${n.commission||0}</div>
          <div style="margin-top:8px;display:flex;gap:6px;">
            <button class="btn btn-secondary btn-sm" onclick="treeAddMember('${n.id}')">+Member</button>
            <button class="btn btn-secondary btn-sm" onclick="editCustomer('${n.id}')">Edit</button>
            <button class="btn btn-danger btn-sm" onclick="deleteCustomer('${n.id}')">Del</button>
          </div>
        </div>`;
      });
      levelsHtml += `</div>`;
      // compute next level
      const next = [];
      level.forEach(id=>{
        const n = nodesById[id];
        if(!n) return;
        if(n.leftId) next.push(n.leftId);
        if(n.rightId) next.push(n.rightId);
      });
      q = next;
    }

    area.innerHTML = levelsHtml;
  }

  // initial start
  // (no auto start — admin must login)

</script>
</body>
</html>
